"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
const crypto = require("crypto");
// cant use teeny-request because typings on return value.
const request = require("request");
const urlModule = require("url");
const url_1 = require("url");
// https://docs.docker.com/registry/spec/api/
// https://github.com/opencontainers/distribution-spec/blob/master/spec.md
class RegistryClient {
    constructor(registry, repository, auth) {
        this._auth = auth; // return from getToken
        this._registry = registry; // gcr.io
        this._repository = repository;
        this._protocol = 'https';
        // this mirrors the behavior or docker itself. always https by default
        // unless its localhost. this should likely be refactored to support image
        // specifiers because i do this better there.
        const hostname = new url_1.URL('http://' + registry).hostname;
        if (hostname === 'localhost' || hostname === '127.0.0.1') {
            this._protocol = 'http';
        }
    }
    tags() {
        return new Promise((resolve, reject) => {
            request.get({
                url: `${this._protocol}://${this._registry}/v2/${this._repository}/tags/list`,
                headers: {
                    Authorization: this.authHeader(),
                    Accept: 'application/vnd.docker.distribution.manifest.v2+json'
                }
            }, (err, res, body) => {
                if (err)
                    return reject(err);
                try {
                    return resolve(JSON.parse(body + ''));
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    manifest(tag) {
        return new Promise((resolve, reject) => {
            const url = `${this._protocol}://${this._registry}/v2/${this._repository}/manifests/${tag}`;
            request.get(url, {
                headers: {
                    Authorization: this.authHeader(),
                    Accept: 'application/vnd.docker.distribution.manifest.v2+json'
                }
            }, (err, res, body) => {
                if (err)
                    return reject(err);
                try {
                    const parsed = JSON.parse(body + '');
                    if (res.statusCode === 200 && parsed.config) {
                        resolve(parsed);
                    }
                    else {
                        reject(new Error('unexpected status code ' + res.statusCode +
                            ' from docker registry (' + url +
                            ' , and auth?: ' + (this.authHeader() ? true : false) +
                            ')  response ' + body));
                    }
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    // upload a manifest and the only way to set a tag on a manifest
    manifestUpload(tag, manifest) {
        return new Promise((resolve, reject) => {
            const manifestBuf = Buffer.isBuffer(manifest) ?
                manifest :
                Buffer.from(JSON.stringify(manifest));
            const digest = 'sha256:' +
                crypto.createHash('sha256').update(manifestBuf).digest('hex');
            if (!tag) {
                // if for some reason you really dont want a tag on this version
                // we need to use the digest as the ref
                tag = digest;
            }
            // tslint:disable-next-line:no-any
            const req = request.put(`${this._protocol}://${this._registry}/v2/${this._repository}/manifests/${tag}`, {
                headers: {
                    Authorization: this.authHeader(),
                    // TODO: read content type from mediaType field of manifest.
                    'content-type': 'application/vnd.docker.distribution.manifest.v2+json'
                }
            }, (err, res, body) => {
                if (err) {
                    return reject(err);
                }
                if (res.statusCode !== 200 && res.statusCode !== 201) {
                    return reject(new Error('unexpected status code ' + req.url + ' ' + res.statusCode +
                        ' ' + body));
                }
                resolve({
                    status: res.statusCode,
                    digest,
                    body
                });
            });
            req.end(manifestBuf);
        });
    }
    blobExists(digest) {
        const url = `${this._protocol}://${this._registry}/v2/${this._repository}/blobs/${digest}`;
        const opts = { url, headers: { Authorization: this.authHeader() } };
        return new Promise((resolve, reject) => {
            request.head(opts, (err, res) => {
                if (err)
                    reject(err);
                resolve(res.statusCode === 200);
            });
        });
    }
    blob(digest, stream) {
        return new Promise((resolve, reject) => {
            const url = `${this._protocol}://${this._registry}/v2/${this._repository}/blobs/${digest}`;
            let loop = 0;
            const fetch = (url) => {
                if (loop++ === 5) {
                    return reject(new Error('redirect looped 5 times ' + url));
                }
                const opts = {
                    url,
                    headers: { Authorization: this.authHeader() },
                    followRedirect: false
                };
                if (url.indexOf(`${this._protocol}://${this._registry}`) === -1) {
                    delete opts.headers.Authorization;
                }
                if (stream) {
                    const req = request.get(opts);
                    req.on('response', (res) => {
                        if (res.headers.location) {
                            res.on('error', () => { });
                            res.on('data', () => { });
                            return fetch(urlModule.resolve(url, res.headers.location));
                        }
                        res.on('error', reject);
                        if (res.statusCode !== 200) {
                            res.on('data', () => { });
                            reject(new Error('unexpected status code ' + url + ' ' + res.statusCode +
                                ' streaming blob'));
                            return;
                        }
                        res.pause();
                        resolve(res);
                    });
                    req.on('error', reject);
                    return;
                }
                request.get(opts, (err, res, body) => {
                    if (err)
                        return reject(err);
                    if (res.headers.location) {
                        return fetch(urlModule.resolve(url, res.headers.location));
                    }
                    if (res.statusCode !== 200) {
                        return reject(new Error('unexpected status code for ' + opts.url + ' ' +
                            res.statusCode + ' ' + body));
                    }
                    return resolve(body);
                });
            };
            fetch(url);
        });
    }
    upload(blob, contentLength, digest) {
        if (!isBuffer(blob)) {
            blob.pause();
        }
        else {
            if (!contentLength)
                contentLength = blob.length;
            if (!digest) {
                digest =
                    'sha256:' + crypto.createHash('sha256').update(blob).digest('hex');
            }
        }
        return new Promise((resolve, reject) => {
            request.post({
                url: `${this._protocol}://${this._registry}/v2/${this._repository}/blobs/uploads/`,
                headers: { Authorization: this.authHeader(), 'Content-Length': 0 }
            }, (err, res, body) => {
                if (err) {
                    return reject(err);
                }
                // use the location header directly instead of the legacy
                // header. docker-upload-uuid see
                // https://github.com/opencontainers/distribution-spec/pull/38 for
                // context (note from jonjohnson@)
                if (!res.headers.location) {
                    return reject(new Error('did not get location header to complete upload from upload post.'));
                }
                let uploadLocation = new url_1.URL(res.headers.location);
                if (contentLength && digest) {
                    // add digest to query
                    uploadLocation.searchParams.set('digest', digest);
                    //`${this._protocol}://${this._registry}/v2/${this._repository}/blobs/uploads/${uuid}?digest=${digest}`
                    const putReq = request.put({
                        url: uploadLocation + '',
                        headers: {
                            Authorization: this.authHeader(),
                            'Content-Length': contentLength,
                            'Content-Type': 'application/octet-stream'
                        }
                    }, (err, res, body) => {
                        if (err) {
                            return reject(err);
                        }
                        if (res.statusCode !== 201) {
                            return reject(new Error('unexpected status code ' + res.statusCode +
                                ' for upload. ' + body));
                        }
                        resolve({
                            contentLength: contentLength + 0,
                            digest: res.headers['docker-content-digest'] + ''
                        });
                    });
                    if (!isBuffer(blob)) {
                        blob.pipe(putReq);
                    }
                    else {
                        putReq.end(blob);
                    }
                    return;
                }
                contentLength = 0;
                const hash = crypto.createHash('sha256');
                const patchReq = request({
                    method: 'PATCH',
                    uri: uploadLocation + '',
                    headers: {
                        Authorization: this.authHeader(),
                        'Content-Type': 'application/octet-stream'
                    }
                }, (err, res, body) => {
                    if (err)
                        return reject(err);
                    if (res.statusCode !== 204) {
                        return reject(new Error('unexpected status code ' + res.statusCode +
                            ' for patch upload (111)' +
                            `${uploadLocation} ${body}`));
                    }
                    // this value changes with every patch request
                    if (res.headers.location) {
                        uploadLocation = new url_1.URL(res.headers.location);
                    }
                    const digest = 'sha256:' + hash.digest('hex');
                    uploadLocation.searchParams.set('digest', digest);
                    const resp = request({
                        method: 'PUT',
                        url: uploadLocation + '',
                        headers: {
                            Authorization: this.authHeader(),
                            'Content-Length': 0,
                            'Content-Type': 'application/octet-stream'
                        }
                    }, (err, res, body) => {
                        if (err)
                            return reject(err);
                        if (res.statusCode !== 201) {
                            return reject(new Error('unexpected status code ' + res.statusCode +
                                ' for upload finalization'));
                        }
                        resolve({ contentLength: contentLength, digest });
                    });
                    if (resp)
                        resp.end();
                });
                if (isBuffer(blob)) {
                    patchReq.end(blob);
                    hash.update(blob);
                    contentLength += blob.length;
                }
                else {
                    blob.pipe(patchReq);
                    blob.resume();
                    blob.on('data', (b) => {
                        hash.update(b);
                        contentLength += b.length;
                    });
                }
            });
        });
    }
    mount(digest, fromRepository) {
        // TODO: mount will have to be able to request another registry. figure out
        // how to send the right auth for this.
        return new Promise((resolve, reject) => {
            request({
                method: 'POST',
                uri: `${this._protocol}://${this._registry}/v2/${this._repository}/blobs/uploads?mount=${digest}&from=${fromRepository}`,
                headers: { Authorization: this.authHeader(), 'Content-Length': 0 }
            }, (err, res, body) => {
                if (err)
                    return reject(err);
                if (res.statusCode !== 201) {
                    return reject(new Error(`mount failed for ${digest} from ${fromRepository} to ${this._repository}`));
                }
                // TODO if it cannot mount it responds with a header to upload.
                resolve(body + '');
            });
        });
    }
    authHeader() {
        if (!this._auth) {
            return undefined;
        }
        if (this._auth.token) {
            return `Bearer ${this._auth.token}`;
        }
        else {
            return 'Basic ' +
                Buffer.from(this._auth.Username + ':' + this._auth.Secret)
                    .toString('base64');
        }
    }
}
exports.RegistryClient = RegistryClient;
function isBuffer(v) {
    return Buffer.isBuffer(v);
}
//# sourceMappingURL=registry.js.map